# try this one:
terrain.colors(3)
# save your colors in an object for re-use
# and add a title to the legend
my_col <- terrain.colors(3)
ggplot() +
geom_raster(data = DSM_HARV_df , aes(x = x, y = y,
fill = fct_elevation_2)) +
scale_fill_manual(values = my_col, name = "Elevation") +
coord_quickmap()
# challenge plot
DSM_HARV_df <- DSM_HARV_df  %>%
mutate(fct_elevation_6 = cut(Elevation, breaks = 6))
my_col <- terrain.colors(6)
ggplot() +
geom_raster(data = DSM_HARV_df , aes(x = x, y = y,
fill = fct_elevation_6)) +
scale_fill_manual(values = my_col, name = "Elevation") +
ggtitle("Classified Elevation Map - NEON Harvard Forest Field Site") +
xlab("UTM Easting Coordinate (m)") +
ylab("UTM Northing Coordinate (m)") +
coord_quickmap()
# layering rasters
DSM_hill_HARV <-
rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_DSMhill.tif")
DSM_hill_HARV
DSM_hill_HARV_df <- as.data.frame(HARV_hill, xy = TRUE)
DSM_hill_HARV_df <- as.data.frame(DSM_hill_HARV, xy = TRUE)
str(DSM_hill_HARV_df)
# plot that with no legend
ggplot() +
geom_raster(data = DSM_hill_HARV_df,
aes(x = x, y = y, alpha = HARV_DSMhill)) +
scale_alpha(range =  c(0.15, 0.65), guide = "none") +
coord_quickmap()
# the top layer needs an alpha if you hope to see it.
# plots build in the order you call the geom's
ggplot() +
geom_raster(data = DSM_HARV_df ,
aes(x = x, y = y,
fill = HARV_dsmCrop)) +
geom_raster(data = DSM_hill_HARV_df,
aes(x = x, y = y,
alpha = HARV_DSMhill)) +
scale_fill_viridis_c() +
scale_alpha(range = c(0.15, 0.65), guide = "none") +
ggtitle("Elevation with hillshade") +
coord_quickmap()
# the top layer needs an alpha if you hope to see it.
# plots build in the order you call the geom's
ggplot() +
geom_raster(data = DSM_HARV_df ,
aes(x = x, y = y,
fill = Elevation)) +
geom_raster(data = DSM_hill_HARV_df,
aes(x = x, y = y,
alpha = HARV_DSMhill)) +
scale_fill_viridis_c() +
scale_alpha(range = c(0.15, 0.65), guide = "none") +
ggtitle("Elevation with hillshade") +
coord_quickmap()
# import DSM data
SJER_DSM <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DSM/SJER_dsmCrop.tif")
# convert to a df for plotting
SJER_DSM_df <- as.data.frame(SJER_DSM, xy = TRUE)
# import DSM hillshade
SJER_DSM_hill <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DSM/SJER_dsmHill.tif")
# convert to a df for plotting
SJER_DSM_hill_df <- as.data.frame(SJER_DSM_hill, xy = TRUE)
# Build Plot
ggplot() +
geom_raster(data = SJER_DSM_df ,
aes(x = x, y = y,
fill = SJER_dsmCrop,
alpha = 0.8)
) +
geom_raster(data = SJER_DSM_hill_df,
aes(x = x, y = y,
alpha = SJER_dsmHill)
) +
scale_fill_viridis_c() +
guides(fill = guide_colorbar()) +
scale_alpha(range = c(0.4, 0.7), guide = "none") +
# remove grey background and grid lines
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
xlab("UTM Easting Coordinate (m)") +
ylab("UTM Northing Coordinate (m)") +
ggtitle("DSM with Hillshade") +
coord_quickmap()
# import DSM data
DSM_SJER <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DSM/SJER_dsmCrop.tif")
# convert to a df for plotting
DSM_SJER_df <- as.data.frame(SJER_DSM, xy = TRUE)
# import DSM hillshade
DSM_hill_SJER <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DSM/SJER_dsmHill.tif")
# convert to a df for plotting
DSM_hill_SJER_df <- as.data.frame(SJER_DSM_hill, xy = TRUE)
# Build Plot
ggplot() +
geom_raster(data = DSM_SJER_df ,
aes(x = x, y = y,
fill = SJER_dsmCrop,
alpha = 0.8)
) +
geom_raster(data = DSM_hill_SJER_df,
aes(x = x, y = y,
alpha = SJER_dsmHill)
) +
scale_fill_viridis_c() +
guides(fill = guide_colorbar()) +
scale_alpha(range = c(0.4, 0.7), guide = "none") +
# remove grey background and grid lines
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
xlab("UTM Easting Coordinate (m)") +
ylab("UTM Northing Coordinate (m)") +
ggtitle("DSM with Hillshade") +
coord_quickmap()
# CREATE DTM MAP
# import DTM
# think: T = Treetops.
DTM_SJER <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DTM/SJER_dtmCrop.tif")
DTM_SJER_df <- as.data.frame(DTM_SJER, xy = TRUE)
# DTM Hillshade
DTM_hill_SJER <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DTM/SJER_dtmHill.tif")
DTM_hill_SJER_df <- as.data.frame(DTM_hill_SJER, xy = TRUE)
ggplot() +
geom_raster(data = DTM_SJER_df ,
aes(x = x, y = y,
fill = SJER_dtmCrop,
alpha = 2.0)
) +
geom_raster(data = DTM_hill_SJER_df,
aes(x = x, y = y,
alpha = SJER_dtmHill)
) +
scale_fill_viridis_c() +
guides(fill = guide_colorbar()) +
scale_alpha(range = c(0.4, 0.7), guide = "none") +
theme_bw() +
theme(panel.grid.major = element_blank(),
panel.grid.minor = element_blank()) +
theme(axis.title.x = element_blank(),
axis.title.y = element_blank()) +
ggtitle("DTM with Hillshade") +
coord_quickmap()
# we made a DTM for SJER. Now let's make one for HARV
DTM_HARV <- rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/DTM/HARV_dtmCrop.tif")
DTM_hill_HARV <- rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/DTM/HARV_DTMhill_WGS84.tif")
DTM_HARV_df <- as.data.frame(DTM_HARV, xy = TRUE)
DTM_hill_HARV_df <- as.data.frame(DTM_hill_HARV, xy = TRUE)
# Exercise
######################################
# we could have figured this out first
# (read the first line)
crs(DTM_HARV, parse = TRUE)
crs(DTM_hill_HARV, parse = TRUE)
DTM_hill_UTMZ18N_HARV <- project(DTM_hill_HARV,
crs(DTM_HARV))
crs(DTM_hill_UTMZ18N_HARV, parse = TRUE)
#compare to before
crs(DTM_hill_HARV, parse = TRUE)
ext(DTM_hill_UTMZ18N_HARV)
ext(DTM_hill_HARV)
#Raster resolution:
res(DTM_hill_UTMZ18N_HARV)
res(DTM_HARV)
# this still doesn't work because the EXTENTS don't match
DTM_hill_UTMZ18N_df <- as.data.frame(DTM_hill_UTMZ18N_HARV, xy=TRUE)
ggplot() +
geom_raster(data = HARV_DTM_df ,
aes(x = x, y = y,
fill = HARV_dtmCrop)) +
geom_raster(data = HARV_DTM_hill_df,
aes(x = x, y = y,
alpha = HARV_DTMhill_WGS84)) +
scale_fill_gradientn(name = "Elevation", colors = terrain.colors(10)) +
coord_quickmap()
ggplot() +
geom_raster(data = DTM_HARV_df ,
aes(x = x, y = y,
fill = HARV_dtmCrop)) +
geom_raster(data = HARV_DTM_hill_df,
aes(x = x, y = y,
alpha = HARV_DTMhill_WGS84)) +
scale_fill_gradientn(name = "Elevation", colors = terrain.colors(10)) +
coord_quickmap()
ggplot() +
geom_raster(data = DTM_HARV_df ,
aes(x = x, y = y,
fill = HARV_dtmCrop)) +
geom_raster(data = DTM_hill_HARV_df,
aes(x = x, y = y,
alpha = HARV_DTMhill_WGS84)) +
scale_fill_gradientn(name = "Elevation", colors = terrain.colors(10)) +
coord_quickmap()
DTM_hill_UTMZ18N_HARV <- project(DTM_hill_HARV,
crs(DTM_HARV),
res = res(DTM_HARV))
res(DTM_hill_UTMZ18N_HARV)
# To plot in ggplot, make a dataframe
DTM_hill_HARV_2_df <- as.data.frame(DTM_hill_UTMZ18N_HARV, xy = TRUE)
ggplot() +
geom_raster(data = DTM_HARV_df ,
aes(x = x, y = y,
fill = HARV_dtmCrop)) +
geom_raster(data = DTM_hill_HARV_2_df,
aes(x = x, y = y,
alpha = HARV_DTMhill_WGS84)) +
scale_fill_gradientn(name = "Elevation", colors = terrain.colors(10)) +
coord_quickmap()
##############################
# challenge: make an overlay for SJER plotting digital terrain model
# import DSM
DSM_SJER <- rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DSM/SJER_dsmCrop.tif")
# import DSM hillshade
DSM_hill_SJER_WGS <-
rast("data/NEON-DS-Airborne-Remote-Sensing/SJER/DSM/SJER_DSMhill_WGS84.tif")
# reproject raster
# This should be DSM not DTM right? Typo in challenge.
DSM_hill_UTMZ18N_SJER<- project(DSM_hill_SJER_WGS,
crs(SJER_DSM),
res = 1)
# convert to data.frames
DSM_SJER_df <- as.data.frame(DSM_SJER, xy = TRUE)
DSM_hill_SJER_df <- as.data.frame(DSM_hill_UTMZ18N_SJER, xy = TRUE)
#need to reload HARV_DSM
DSM_HARV <-
rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/DSM/HARV_dsmCrop.tif")
DSM_HARV_df <- as.data.frame(DSM_HARV, xy = TRUE)
names(DSM_HARV_df)[names(DSM_HARV_df) == 'HARV_dsmCrop'] <- 'Elevation'
# Terrain
# Think "Treetops"
ggplot() +
geom_raster(data = DTM_HARV_df ,
aes(x = x, y = y, fill = HARV_dtmCrop)) +
scale_fill_gradientn(name = "Elevation", colors = terrain.colors(10)) +
coord_quickmap()
# do math to create canopy height model
CHM_HARV <- DSM_HARV - DTM_HARV
CHM_HARV_df <- as.data.frame(CHM_HARV, xy = TRUE)
ggplot() +
geom_raster(data = CHM_HARV_df ,
aes(x = x, y = y, fill = HARV_dsmCrop)) +
scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) +
coord_quickmap()
#check distribution of values
ggplot(CHM_HARV_df) +
geom_histogram(aes(HARV_dsmCrop))
# challenge
min(CHM_HARV_df$HARV_dsmCrop, na.rm = TRUE)
max(CHM_HARV_df$HARV_dsmCrop, na.rm = TRUE)
ggplot(CHM_HARV_df) +
geom_histogram(aes(HARV_dsmCrop))
ggplot(CHM_HARV_df) +
geom_histogram(aes(HARV_dsmCrop), colour="black",
fill="darkgreen", bins = 6)
# the above has auto-breaks. we want to specify our own.
custom_bins <- c(0, 10, 20, 30, 40)
CHM_HARV_df <- CHM_HARV_df %>%
mutate(canopy_discrete = cut(HARV_dsmCrop,
breaks = custom_bins))
ggplot() +
geom_raster(data = CHM_HARV_df, aes(x = x, y = y,
fill = canopy_discrete)) +
scale_fill_manual(values = terrain.colors(4)) +
coord_quickmap()
# this is the second way to do raster math: an overlay
CHM_ov_HARV <- lapp(sds(list(DSM_HARV,DTM_HARV)),
fun = function(r1, r2) { return( r1 - r2) })
CHM_ov_HARV_df <- as.data.frame(CHM_ov_HARV, xy = TRUE)
ggplot() +
geom_raster(data = CHM_ov_HARV_df,
aes(x = x, y = y, fill = HARV_dsmCrop)) +
scale_fill_gradientn(name = "Canopy Height", colors = terrain.colors(10)) +
coord_quickmap()
## SJER Challenge
CHM_ov_SJER <- lapp(sds(list(DSM_SJER, DTM_SJER)),
fun = function(r1, r2){ return(r1 - r2) })
CHM_ov_SJER_df <- as.data.frame(CHM_ov_SJER, xy = TRUE)
ggplot(CHM_ov_SJER_df) +
geom_histogram(aes(SJER_dsmCrop))
# open a single band of a multi-band image:
RGB_band1_HARV <- rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/RGB_Imagery/HARV_RGB_Ortho.tif")
RGB_band1_HARV_df  <- as.data.frame(RGB_band1_HARV, xy = TRUE)
#where did HARV_RGB_Ortho come from?
#is it HARV_RGB_Ortho_1?
ggplot() +
geom_raster(data = RGB_band1_HARV_df,
aes(x = x, y = y, alpha = HARV_RGB_Ortho_1)) +
coord_quickmap()
#Challenge: view attributes of band 1
RGB_band1_HARV
RGB_band2_HARV <-  rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/RGB_Imagery/HARV_RGB_Ortho.tif", lyrs = 2)
RGB_band2_HARV_df <- as.data.frame(RGB_band2_HARV, xy = TRUE)
# similarly boring and familiar plot
ggplot() +
geom_raster(data = RGB_band2_HARV_df,
aes(x = x, y = y, alpha = HARV_RGB_Ortho_2)) +
coord_equal()
# multi-bands get called as 'stacks'
RGB_stack_HARV <- rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/RGB_Imagery/HARV_RGB_Ortho.tif")
# we can see all 3 bands:
RGB_stack_HARV
# view attributes of each band by using index values
RGB_stack_HARV[[2]]
# make a dataframe
RGB_stack_HARV_df  <- as.data.frame(RGB_stack_HARV, xy = TRUE)
str(RGB_stack_HARV_df)
# create histogram of band 1
ggplot()+
geom_histogram(data=RGB_stack_HARV_df, aes(HARV_RGB_Ortho_1))
ggplot()+
geom_raster(data = RGB_stack_HARV_df,
aes(x=x, y=y, alpha = HARV_RGB_Ortho_2))+
coord_quickmap()
# Creating a 3-band image:
plotRGB(RGB_stack_HARV,
r = 1, g = 2, b = 3)
#############################
# challenge raster
describe("data/NEON-DS-Airborne-Remote-Sensing/HARV/RGB_Imagery/HARV_Ortho_wNA.tif")
HARV_NA <- rast("data/NEON-DS-Airborne-Remote-Sensing/HARV/RGB_Imagery/HARV_Ortho_wNA.tif")
plotRGB(HARV_NA,
r = 1, g = 2, b = 3)
describe("data/NEON-DS-Airborne-Remote-Sensing/HARV/RGB_Imagery/HARV_RGB_Ortho.tif")
RGB_sds_HARV <- sds(RGB_stack_HARV)
RGB_sds_HARV <-sds(list(RGB_stack_HARV, RGB_stack_HARV))
RGB_sds_HARV[[1]]
RGB_sds_HARV[[2]]
# our first new library in a while
#install.packages("sf")
library(sf)
# vector files are shapefiles
aoi_boundary_HARV <- st_read(
"data/NEON-DS-Site-Layout-Files/HARV/HarClip_UTMZ18.shp")
# there are 18 types of shapefiles.
# this one is polygons
st_geometry_type(aoi_boundary_HARV)
# and it has CRS metadata baked into it
st_crs(aoi_boundary_HARV)
# one of those pieces of data is a bounding box
# you will need these in your future life
st_bbox(aoi_boundary_HARV)
# mostly we want to make maps
# this is not a useful map
ggplot() +
geom_sf(data = aoi_boundary_HARV, size = 3, color = "black", fill = "cyan1") +
ggtitle("AOI Boundary Plot") +
coord_sf()
# Let's move on to point and line shapefiles
lines_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARV_roads.shp")
point_HARV <- st_read("data/NEON-DS-Site-Layout-Files/HARV/HARVtower_UTM18N.shp")
# that's a "spatial" "dataframe"
class(lines_HARV)
class(point_HARV)
# it's got a CRS
# just like raster data does
# what's the raster version of the command?
st_crs(lines_HARV)
# bounding boxes make more sense when your
# shapefile is more than just a single rectangle
st_bbox(lines_HARV)
st_crs(point_HARV)
st_bbox(point_HARV)
# this shows us the attribute table
# there's only one point
View(point_HARV)
# this shows us the attribute table
# there's only one point
point_HARV
# we can count the attributes
ncol(lines_HARV)
# we can view the attribute names
names(lines_HARV)
names(points_HARV)
names(point_HARV)
# our old friend helps too:
head(lines_HARV)
ncol(aoi_boundary_HARV)
#find number of attributes
ncol(point_HARV)
# call out a whole column / attribute:
point_HARV$Ownership
names(point_HARV)
lines_HARV$TYPE
#To see only unique values
unique(lines_HARV$TYPE)
# all this stuff works with the tidyverse
# so you can use pipes
footpath_HARV <- lines_HARV %>%
filter(TYPE == "footpath")
nrow(footpath_HARV)
# now the exciting part, let's map it
ggplot() +
geom_sf(data = footpath_HARV) +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Footpaths") +
coord_sf()
ggplot() +
geom_sf(data = footpath_HARV, aes(color = factor(OBJECTID)), size = 1.5) +
labs(color = 'Footpath ID') +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Footpaths") +
coord_sf()
# challenge 1
boardwalk_HARV <- lines_HARV %>%
filter(TYPE == "boardwalk")
# there's 1 row
nrow(boardwalk_HARV)
ggplot() +
geom_sf(data = boardwalk_HARV, size = 1.5) +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Boardwalks") +
coord_sf()
# challenge 2
stoneWall_HARV <- lines_HARV %>%
filter(TYPE == "stone wall")
nrow(stoneWall_HARV)
ggplot() +
geom_sf(data = stoneWall_HARV, aes(color = factor(OBJECTID)), size = 1.5) +
labs(color = 'Wall ID') +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Stonewalls") +
coord_sf()
# this just moves on in the lesson
# but if we want to see unique values,
# we have to get that column to be a factor
unique(HARV_lines$TYPE)
# this just moves on in the lesson
# but if we want to see unique values,
# we have to get that column to be a factor
unique(lines_HARV$TYPE)
unique(HARV_lines$TYPE)
unique(lines_HARV$TYPE)
road_colors <- c("blue", "green", "navy", "purple")
ggplot() +
geom_sf(data = lines_HARV, aes(color = TYPE)) +
scale_color_manual(values = road_colors) +
labs(color = 'Road Type') +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Roads & Trails") +
coord_sf()
# use different line widths
line_widths <- c(1, 2, 3, 4)
ggplot() +
geom_sf(data = lines_HARV, aes(color = TYPE, size = TYPE)) +
scale_color_manual(values = road_colors) +
labs(color = 'Road Type') +
scale_size_manual(values = line_widths) +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Roads & Trails - Line width varies") +
coord_sf()
##Challenge: Plot line width by attribute
# they come out in the order they are stored,
# so you can assign in that order
unique(HARV_lines$TYPE)
##Challenge: Plot line width by attribute
# they come out in the order they are stored,
# so you can assign in that order
unique(lines_HARV$TYPE)
line_width <- c(1, 3, 2, 6)
ggplot() +
geom_sf(data = lines_HARV, aes(size = TYPE)) +
scale_size_manual(values = line_width) +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Roads & Trails - Line width varies") +
coord_sf()
# work on that legend
ggplot() +
geom_sf(data = lines_HARV, aes(color = TYPE), size = 1.5) +
scale_color_manual(values = road_colors) +
labs(color = 'Road Type') +
ggtitle("NEON Harvard Forest Field Site",
subtitle = "Roads & Trails - Default Legend") +
coord_sf()
# change legend text and draw a box around it
ggplot() +
geom_sf(data = lines_HARV, aes(color = TYPE), size = 1.5) +
scale_color_manual(values = road_colors) +
labs(color = 'Road Type') +
theme(legend.text = element_text(size = 14),
legend.box.background = element_rect(size = 1)) +
ggtitle("NEON Harvard Forest Field Site",
subtitle = "Roads & Trails - Modified Legend") +
coord_sf()
# make the colors less obnoxious
new_colors <- c("springgreen", "blue", "magenta", "orange")
ggplot() +
geom_sf(data = lines_HARV, aes(color = TYPE), size = 1.5) +
scale_color_manual(values = new_colors) +
labs(color = 'Road Type') +
theme(legend.text = element_text(size = 14),
legend.box.background = element_rect(size = 1)) +
ggtitle("NEON Harvard Forest Field Site",
subtitle = "Roads & Trails - Pretty Colors") +
coord_sf()
# bicycle challenge
class(lines_HARV$BIKEHORSE)
# bicycle challenge
lines_HARV$BicyclesHo <- as.factor(lines_HARV$BicyclesHo)
class(lines_HARV$BicyclesHo)
# same iss ue as roadtype
levels(lines_HARV$BicyclesHo)
lines_removeNA <- lines_HARV[!is.na(lines_HARV$BicyclesHo),]
# First, create a data frame with only those roads where bicycles and horses are allowed
lines_showHarv <-
lines_removeNA %>%
filter(BicyclesHo == "Bicycles and Horses Allowed")
# Next, visualise using ggplot
ggplot() +
geom_sf(data = lines_HARV) +
geom_sf(data = lines_showHarv, aes(color = BicyclesHo), size = 2) +
scale_color_manual(values = "magenta") +
ggtitle("NEON Harvard Forest Field Site", subtitle = "Roads Where Bikes and Horses Are Allowed") +
coord_sf()
